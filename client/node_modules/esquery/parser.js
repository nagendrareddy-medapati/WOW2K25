/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define([], factory);
  } else if (typeof module === "object" && module.exports) {
    module.exports = factory();
  }
})(this, function() {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = function(ss) {
            return ss.length === 1 ? ss[0] : { type: 'matches', selectors: ss };
          },
        peg$c1 = function() { return void 0; },
        peg$c2 = " ",
        peg$c3 = peg$literalExpectation(" ", false),
        peg$c4 = /^[^ [\],():#!=><~+.]/,
        peg$c5 = peg$classExpectation([" ", "[", "]", ",", "(", ")", ":", "#", "!", "=", ">", "<", "~", "+", "."], true, false),
        peg$c6 = function(i) { return i.join(''); },
        peg$c7 = ">",
        peg$c8 = peg$literalExpectation(">", false),
        peg$c9 = function() { return 'child'; },
        peg$c10 = "~",
        peg$c11 = peg$literalExpectation("~", false),
        peg$c12 = function() { return 'sibling'; },
        peg$c13 = "+",
        peg$c14 = peg$literalExpectation("+", false),
        peg$c15 = function() { return 'adjacent'; },
        peg$c16 = function() { return 'descendant'; },
        peg$c17 = ",",
        peg$c18 = peg$literalExpectation(",", false),
        peg$c19 = function(s, ss) {
          return [s].concat(ss.map(function (s) { return s[3]; }));
        },
        peg$c20 = function(op, s) {
            if (!op) return s;
            return { type: op, left: { type: 'exactNode' }, right: s };
          },
        peg$c21 = function(a, ops) {
            return ops.reduce(function (memo, rhs) {
              return { type: rhs[0], left: memo, right: rhs[1] };
            }, a);
          },
        peg$c22 = "!",
        peg$c23 = peg$literalExpectation("!", false),
        peg$c24 = function(subject, as) {
            const b = as.length === 1 ? as[0] : { type: 'compound', selectors: as };
            if(subject) b.subject = true;
            return b;
          },
        peg$c25 = "*",
        peg$c26 = peg$literalExpectation("*", false),
        peg$c27 = function(a) { return { type: 'wildcard', value: a }; },
        peg$c28 = "#",
        peg$c29 = peg$literalExpectation("#", false),
        peg$c30 = function(i) { return { type: 'identifier', value: i }; },
        peg$c31 = "[",
        peg$c32 = peg$literalExpectation("[", false),
        peg$c33 = "]",
        peg$c34 = peg$literalExpectation("]", false),
        peg$c35 = function(v) { return v; },
        peg$c36 = /^[><!]/,
        peg$c37 = peg$classExpectation([">", "<", "!"], false, false),
        peg$c38 = "=",
        peg$c39 = peg$literalExpectation("=", false),
        peg$c40 = function(a) { return (a || '') + '='; },
        peg$c41 = /^[><]/,
        peg$c42 = peg$classExpectation([">", "<"], false, false),
        peg$c43 = ".",
        peg$c44 = peg$literalExpectation(".", false),
        peg$c45 = function(a, as) {
            return [].concat.apply([a], as).join('');
          },
        peg$c46 = function(name, op, value) {
              return { type: 'attribute', name: name, operator: op, value: value };
            },
        peg$c47 = function(name) { return { type: 'attribute', name: name }; },
        peg$c48 = "\"",
        peg$c49 = peg$literalExpectation("\"", false),
        peg$c50 = /^[^\\"]/,
        peg$c51 = peg$classExpectation(["\\", "\""], true, false),
        peg$c52 = "\\",
        peg$c53 = peg$literalExpectation("\\", false),
        peg$c54 = peg$anyExpectation(),
        peg$c55 = function(a, b) { return a + b; },
        peg$c56 = function(d) {
                return { type: 'literal', value: strUnescape(d.join('')) };
              },
        peg$c57 = "'",
        peg$c58 = peg$literalExpectation("'", false),
        peg$c59 = /^[^\\']/,
        peg$c60 = peg$classExpectation(["\\", "'"], true, false),
        peg$c61 = /^[0-9]/,
        peg$c62 = peg$classExpectation([["0", "9"]], false, false),
        peg$c63 = function(a, b) {
                // Can use `a.flat().join('')` once supported
                const leadingDecimals = a ? [].concat.apply([], a).join('') : '';
                return { type: 'literal', value: parseFloat(l